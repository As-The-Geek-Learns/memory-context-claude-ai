"""Git-tracked projections for Cortex decisions and plans.

Generates markdown files in `.cortex/` directory that can be committed to git,
providing PR context and decision history visibility in version control.

Files generated:
- .cortex/decisions.md: Active decisions with reasoning
- .cortex/decisions-archive.md: Archived/aged decisions
- .cortex/active-plan.md: Current work plan with completed steps

These files are auto-generated from the event store and should not be manually
edited. On merge conflict, regenerate from the event store (files are derived).
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from cortex.config import CortexConfig
    from cortex.models import Event
    from cortex.store import EventStoreBase


# Header comment for generated files
GENERATED_HEADER = """\
<!--
  This file is auto-generated by Cortex. Do not edit manually.
  Regenerate with: cortex regenerate-projections
  On merge conflict: Accept incoming changes, then regenerate.
-->

"""


@dataclass
class ProjectionStats:
    """Statistics from projection generation.

    Attributes:
        decisions_count: Number of active decisions written.
        archived_count: Number of archived decisions written.
        plan_steps: Number of plan steps (created + completed).
        files_written: List of files that were written.
    """

    decisions_count: int = 0
    archived_count: int = 0
    plan_steps: int = 0
    files_written: list[str] | None = None

    def __post_init__(self) -> None:
        if self.files_written is None:
            self.files_written = []


def get_projections_dir(project_root: str) -> Path:
    """Get the .cortex/ directory path for projections.

    Args:
        project_root: Root directory of the project.

    Returns:
        Path to .cortex/ directory (created if needed).
    """
    projections_dir = Path(project_root) / ".cortex"
    projections_dir.mkdir(parents=True, exist_ok=True)
    return projections_dir


def generate_decisions_md(
    events: list["Event"],
    active_sessions: int = 20,
    branch: str | None = None,
) -> str:
    """Generate markdown content for active decisions.

    Active decisions are those accessed within `active_sessions` sessions.
    Immortal events (decisions, rejections) are included.

    Args:
        events: List of all events from the store.
        active_sessions: Session threshold for "active" status.
        branch: Filter by git branch (None = all branches).

    Returns:
        Markdown content for decisions.md file.
    """
    from cortex.models import EventType

    # Filter to immortal events only
    decision_types = {EventType.DECISION_MADE, EventType.APPROACH_REJECTED}
    decisions = [e for e in events if e.type in decision_types and e.immortal]

    # Filter by branch if specified
    if branch:
        decisions = [e for e in decisions if e.git_branch == branch]

    # Sort by created_at descending (most recent first)
    decisions.sort(key=lambda e: e.created_at or "", reverse=True)

    # Build markdown
    lines = [GENERATED_HEADER, "# Active Decisions\n"]

    if not decisions:
        lines.append("*No active decisions recorded.*\n")
        return "\n".join(lines)

    lines.append(f"*{len(decisions)} decision(s) | Updated: {_now_iso()}*\n")

    for event in decisions:
        emoji = "✓" if event.type == EventType.DECISION_MADE else "✗"
        label = "Decision" if event.type == EventType.DECISION_MADE else "Rejected"
        branch_info = f" ({event.git_branch})" if event.git_branch else ""

        lines.append(f"## {emoji} {label}{branch_info}\n")
        lines.append(event.content.strip())
        lines.append("")

        if event.created_at:
            lines.append(f"*{event.created_at[:10]}*\n")

    return "\n".join(lines)


def generate_archive_md(
    events: list["Event"],
    active_sessions: int = 20,
    aging_sessions: int = 50,
    branch: str | None = None,
) -> str:
    """Generate markdown content for archived decisions.

    Archived decisions are those beyond the active threshold but still
    within the aging threshold. Beyond aging, decisions are summarized.

    Args:
        events: List of all events from the store.
        active_sessions: Session threshold for "active" status.
        aging_sessions: Session threshold for "aging" status.
        branch: Filter by git branch (None = all branches).

    Returns:
        Markdown content for decisions-archive.md file.
    """
    from cortex.models import EventType

    # Filter to immortal events
    decision_types = {EventType.DECISION_MADE, EventType.APPROACH_REJECTED}
    decisions = [e for e in events if e.type in decision_types and e.immortal]

    # Filter by branch if specified
    if branch:
        decisions = [e for e in decisions if e.git_branch == branch]

    # For now, archive includes all decisions (tiering based on access_count
    # would require tracking session counts, which we can add later)
    archived = decisions

    # Sort by created_at ascending (oldest first for archive)
    archived.sort(key=lambda e: e.created_at or "")

    lines = [GENERATED_HEADER, "# Decision Archive\n"]

    if not archived:
        lines.append("*No archived decisions.*\n")
        return "\n".join(lines)

    lines.append(f"*{len(archived)} decision(s) in archive*\n")

    # Group by month for readability
    current_month = ""
    for event in archived:
        if event.created_at:
            month = event.created_at[:7]  # YYYY-MM
            if month != current_month:
                current_month = month
                lines.append(f"## {month}\n")

        emoji = "✓" if event.type == EventType.DECISION_MADE else "✗"
        # One-line summary for archive
        content_summary = event.content.split("\n")[0][:100]
        if len(event.content) > 100:
            content_summary += "..."
        lines.append(f"- {emoji} {content_summary}")

    lines.append("")
    return "\n".join(lines)


def generate_plan_md(
    events: list["Event"],
    branch: str | None = None,
) -> str:
    """Generate markdown content for active work plan.

    Shows the most recent plan with completed steps marked.

    Args:
        events: List of all events from the store.
        branch: Filter by git branch (None = all branches).

    Returns:
        Markdown content for active-plan.md file.
    """
    from cortex.models import EventType

    # Get plan events
    plans = [e for e in events if e.type == EventType.PLAN_CREATED]
    completed = [e for e in events if e.type == EventType.PLAN_STEP_COMPLETED]

    # Filter by branch
    if branch:
        plans = [e for e in plans if e.git_branch == branch]
        completed = [e for e in completed if e.git_branch == branch]

    lines = [GENERATED_HEADER, "# Active Plan\n"]

    if not plans:
        lines.append("*No active plan.*\n")
        return "\n".join(lines)

    # Get most recent plan
    plans.sort(key=lambda e: e.created_at or "", reverse=True)
    active_plan = plans[0]

    lines.append(f"*Created: {active_plan.created_at[:10] if active_plan.created_at else 'unknown'}*\n")

    if active_plan.git_branch:
        lines.append(f"*Branch: {active_plan.git_branch}*\n")

    lines.append("## Plan\n")
    lines.append(active_plan.content.strip())
    lines.append("")

    # Show completed steps
    if completed:
        lines.append("## Completed Steps\n")
        for step in completed:
            lines.append(f"- ✓ {step.content}")
        lines.append("")

    return "\n".join(lines)


def regenerate_all(
    store: "EventStoreBase",
    project_root: str,
    branch: str | None = None,
    config: "CortexConfig | None" = None,
) -> ProjectionStats:
    """Regenerate all projection files from the event store.

    Writes:
    - .cortex/decisions.md
    - .cortex/decisions-archive.md
    - .cortex/active-plan.md

    Args:
        store: Event store to read events from.
        project_root: Root directory of the project.
        branch: Filter by git branch (None = all branches).
        config: Optional config for thresholds.

    Returns:
        Statistics about what was generated.
    """
    from cortex.config import CortexConfig

    config = config or CortexConfig()
    projections_dir = get_projections_dir(project_root)

    # Load all events
    events = store.load_all()

    # Generate files
    stats = ProjectionStats()

    # Decisions
    decisions_content = generate_decisions_md(
        events,
        active_sessions=config.decision_active_sessions,
        branch=branch,
    )
    decisions_path = projections_dir / "decisions.md"
    decisions_path.write_text(decisions_content, encoding="utf-8")
    stats.files_written.append(str(decisions_path))
    stats.decisions_count = decisions_content.count("## ✓") + decisions_content.count("## ✗")

    # Archive
    archive_content = generate_archive_md(
        events,
        active_sessions=config.decision_active_sessions,
        aging_sessions=config.decision_aging_sessions,
        branch=branch,
    )
    archive_path = projections_dir / "decisions-archive.md"
    archive_path.write_text(archive_content, encoding="utf-8")
    stats.files_written.append(str(archive_path))
    stats.archived_count = archive_content.count("- ✓") + archive_content.count("- ✗")

    # Plan
    plan_content = generate_plan_md(events, branch=branch)
    plan_path = projections_dir / "active-plan.md"
    plan_path.write_text(plan_content, encoding="utf-8")
    stats.files_written.append(str(plan_path))
    stats.plan_steps = plan_content.count("- ✓")

    return stats


def should_regenerate(
    store: "EventStoreBase",
    project_root: str,
) -> bool:
    """Check if projections should be regenerated.

    Returns True if:
    - Projection files don't exist
    - New decisions have been added since last generation

    Args:
        store: Event store to check.
        project_root: Root directory of the project.

    Returns:
        True if regeneration is recommended.
    """

    projections_dir = Path(project_root) / ".cortex"

    # Check if files exist
    required_files = ["decisions.md", "decisions-archive.md", "active-plan.md"]
    for filename in required_files:
        if not (projections_dir / filename).exists():
            return True

    # Check for immortal events (simple heuristic - always regenerate if any exist)
    events = store.load_immortal()
    if events:
        return True

    return False


def _now_iso() -> str:
    """Return current UTC timestamp in ISO format."""
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
